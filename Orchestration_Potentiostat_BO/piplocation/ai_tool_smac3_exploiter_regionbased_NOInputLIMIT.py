import os, random, pandas as pd, numpy as np
from typing import List
from ConfigSpace import ConfigurationSpace, UniformIntegerHyperparameter, Configuration
from smac import Scenario
from smac.facade.hyperparameter_optimization_facade import HyperparameterOptimizationFacade
from smac.acquisition.function import EI
from smac.runhistory.runhistory import RunHistory
from smac.runhistory.enumerations import StatusType
from smac.runhistory.dataclasses import TrialValue
from smac.initial_design.abstract_initial_design import AbstractInitialDesign
from smac.utils.logging import get_logger

class SMAC3():
    """Region-based SMAC3: exploit top-3 peaks in rotating trust-regions."""
    def __init__(self, input_file, output_file, num_objectives,
                 num_proposals, num_inputs):
        self.input_file     = input_file
        self.output_file    = output_file
        self.num_objectives = num_objectives
        self.num_proposals  = num_proposals
        self.num_inputs     = num_inputs

        self.min_input_value = 20
        self.max_sum         = 330
        self.max_input_value = self.max_sum - self.min_input_value * (self.num_inputs - 1)

        self._ensure_input_file_exists()

    def _ensure_input_file_exists(self):
        if not os.path.isfile(self.input_file):
            cols = [f"input_{i+1}" for i in range(self.num_inputs)] + \
                   [f"objective_{i+1}" for _ in range(self.num_objectives)]
            pd.DataFrame(columns=cols).to_csv(self.input_file, index=False)
            print(f"Created {self.input_file} with header {cols}")

    def _append_row(self, inputs, obj):
        df, _ = self.load_data()
        df.loc[len(df)] = inputs + [obj]
        df.to_csv(self.input_file, index=False)

    def load_data(self):
        df = pd.read_csv(self.input_file)
        return df, not df.dropna().empty

    def objective_function(self, config, seed=None):
        vals = [config[f"input_{i+1}"] for i in range(self.num_inputs)]
        return 1e2 if sum(vals) > self.max_sum else 0.0

    def run_smac(self):
        
        maxima2exploit = 6
        data, has_prior = self.load_data()

        # Pick them
        df = data.dropna(subset=['objective_1'])
        df = df.sort_values('objective_1', ascending=False).head(maxima2exploit)
        centers = df[[f'input_{i+1}' for i in range(self.num_inputs)]].values.tolist()

        # Round-robin choice of center
        idx = len(data) % len(centers)
        center = centers[idx]
        radius = 10  # like 10 units of increase-decrease around the suspected maxima

        # Build local CS around that center
        cs = ConfigurationSpace()
        bounds = []
        for i, c in enumerate(center):
            lo = max(self.min_input_value, c - radius)
            hi = min(self.max_input_value, c + radius)
            cs.add(UniformIntegerHyperparameter(f"input_{i+1}", lo, hi))
            bounds.append((lo, hi))

        # Create SMAC pure exploitation
        scenario = Scenario(
            cs,
            deterministic=True,
            n_trials=100,
            seed=random.randint(0, 2**32 - 1),
        )
        smac = HyperparameterOptimizationFacade(
            scenario=scenario,
            target_function=self.objective_function,
            acquisition_function=EI(xi=0.05),  # pure exploitation
            initial_design=ConstrainedRandomInitialDesign(
                scenario=scenario,
                num_inputs=self.num_inputs,
                max_sum=self.max_sum,
            ),
        )

        # Replay only those priors *inside* the region
        if has_prior:
            rh = RunHistory()
            for _, row in data.iterrows():
                vals = [int(row[f"input_{i+1}"]) for i in range(self.num_inputs)]
                # skip points outside the trust-region
                if not all(lo <= v <= hi for (lo, hi), v in zip(bounds, vals)):
                    continue
                cfg = {f"input_{i+1}": v for i, v in enumerate(vals)}
                cost = -float(row['objective_1'])
                rh.add(Configuration(cs, cfg),
                       cost=cost, time=0.0,
                       status=StatusType.SUCCESS,
                       seed=0)
            smac.runhistory.update(rh)

        # One-shot ask–check–append
        while True:
            trial = smac.ask()
            cfg   = trial.config
            inputs = [cfg[f"input_{i+1}"] for i in range(self.num_inputs)]

            if sum(inputs) <= self.max_sum:
                print("Region-based proposal:", inputs, "around", center)
                self._append_row(inputs, np.nan)
                return inputs

            # infeasible → penalise
            pen = TrialValue(cost=1e2, time=0.0, status=StatusType.CRASHED)
            smac.tell(trial, pen)
            self._append_row(inputs, -1e2)

    def select(self):
        print("Start SMAC3 region-based exploitation")
        prop = self.run_smac()
        print("Proposed inputs:", prop)
        return True

class ConstrainedRandomInitialDesign(AbstractInitialDesign):
    def __init__(self, scenario, num_inputs, max_sum, **kw):
        super().__init__(scenario=scenario, **kw)
        self.num_inputs = num_inputs
        self.max_sum    = max_sum
        self.logger     = get_logger(self.__class__.__name__)

    def _select_configurations(self) -> List[Configuration]:
        configs, tries = [], 0
        while len(configs) < self._n_configs and tries < 1000*self._n_configs:
            cfg  = self._configspace.sample_configuration()
            vals = [cfg[f"input_{i+1}"] for i in range(self.num_inputs)]
            if sum(vals) <= self.max_sum:
                configs.append(cfg)
            tries += 1
        if len(configs) < self._n_configs:
            self.logger.warning(
                f"Only generated {len(configs)} valid configs out of {self._n_configs}")
        return configs
