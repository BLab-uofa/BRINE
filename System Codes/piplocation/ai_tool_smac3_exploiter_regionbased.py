import os, random, pandas as pd, numpy as np
from typing import List
from ConfigSpace import ConfigurationSpace, UniformIntegerHyperparameter, Configuration
from smac import Scenario
from smac.facade.hyperparameter_optimization_facade import HyperparameterOptimizationFacade
from smac.acquisition.function import EI
from smac.runhistory.runhistory import RunHistory
from smac.runhistory.enumerations import StatusType
from smac.runhistory.dataclasses import TrialValue
from smac.initial_design.abstract_initial_design import AbstractInitialDesign
from smac.utils.logging import get_logger


class SMAC3():
    """Region-based SMAC3: exploit top-N peaks in rotating trust-regions."""
    def __init__(self, input_file, output_file, num_objectives,
                 num_proposals, num_inputs):
        self.input_file     = input_file
        self.output_file    = output_file
        self.num_objectives = num_objectives
        self.num_proposals  = num_proposals
        self.num_inputs     = num_inputs

        self.min_input_values = [20] * self.num_inputs
        self.min_input_values[0] = 33

        self.max_sum = 330
        total_min = sum(self.min_input_values)

        self.max_input_values = [
            self.max_sum - (total_min - m)
            for m in self.min_input_values
        ]
        self._ensure_input_file_exists()
        
        
    def _ensure_input_file_exists(self):
        if not os.path.isfile(self.input_file):
            cols = [f"input_{i+1}" for i in range(self.num_inputs)] + \
                   [f"objective_{i+1}" for _ in range(self.num_objectives)]
            pd.DataFrame(columns=cols).to_csv(self.input_file, index=False)
            print(f"Created {self.input_file} with header {cols}")
            
            
    def _append_row(self, inputs, obj):
        df, _ = self.load_data()
        df.loc[len(df)] = inputs + [obj]
        df.to_csv(self.input_file, index=False)
        
        
    def load_data(self):
        df = pd.read_csv(self.input_file)
        return df, not df.dropna(subset=['objective_1']).empty
    
    def objective_function(self, config, seed=None):
        vals = [config[f"input_{i+1}"] for i in range(self.num_inputs)]
        return 1e2 if sum(vals) > self.max_sum else 0.0
    
    def run_smac(self):
        maxima2exploit = 6
        
    
        data, has_prior = self.load_data()
        # Select top-K peaks to exploit
        df = data.dropna(subset=['objective_1'])
        df = df.sort_values('objective_1', ascending=False).head(maxima2exploit)
        centers = df[[f'input_{i+1}' for i in range(self.num_inputs)]].values.tolist()
        # Round-robin choice of center
        idx    = len(data) % len(centers)
        center = centers[idx]
        
        radius = 10
        
        # Build a local CS around that center
        cs     = ConfigurationSpace()
        bounds = []
        for i, c in enumerate(center):
            lo = max(self.min_input_values[i], c - radius)
            hi = min(self.max_input_values[i], c + radius)
            cs.add(UniformIntegerHyperparameter(f"input_{i+1}", lo, hi))
            bounds.append((lo, hi))
        # SMAC setup: pure exploitation (EI with xi=0.05)
        scenario = Scenario(
            cs,
            deterministic=True,
            n_trials=100,
            seed=random.randint(0, 2**32 - 1),
        )
        smac = HyperparameterOptimizationFacade(
            scenario=scenario,
            target_function=self.objective_function,
            acquisition_function=EI(xi=0.05),
            initial_design=ConstrainedRandomInitialDesign(
                scenario=scenario,
                num_inputs=self.num_inputs,
                max_sum=self.max_sum,
            ),
        )
        # Replay only priors *inside* this region
        if has_prior:
            rh = RunHistory()
            for _, row in data.iterrows():
                vals = [int(row[f"input_{i+1}"]) for i in range(self.num_inputs)]
                if not all(lo <= v <= hi for (lo, hi), v in zip(bounds, vals)):
                    continue
                cfg  = {f"input_{i+1}": v for i, v in enumerate(vals)}
                cost = -float(row['objective_1'])
                rh.add(Configuration(cs, cfg),
                       cost=cost, time=0.0,
                       status=StatusType.SUCCESS,
                       seed=0)
            smac.runhistory.update(rh)
        # Ask–check–append, *only* accept proposals inside bounds
        while True:
            trial  = smac.ask()
            cfg    = trial.config
            inputs = [cfg[f"input_{i+1}"] for i in range(self.num_inputs)]
            if all(lo <= v <= hi for (lo, hi), v in zip(bounds, inputs)):
                print("Region-based proposal:", inputs, "around", center)
                self._append_row(inputs, np.nan)
                return inputs
            # outside region → penalise and record
            pen = TrialValue(cost=1e2, time=0.0, status=StatusType.CRASHED)
            smac.tell(trial, pen)
            self._append_row(inputs, -1e2)
            
            
    def select(self):
        print("Start SMAC3 region-based exploitation")
        prop = self.run_smac()
        print("Proposed inputs:", prop)
        return True
    
    
class ConstrainedRandomInitialDesign(AbstractInitialDesign):
    def __init__(self, scenario, num_inputs, max_sum, **kw):
        super().__init__(scenario=scenario, **kw)
        self.num_inputs = num_inputs
        self.max_sum    = max_sum
        self.logger     = get_logger(self.__class__.__name__)
        
    def _select_configurations(self) -> List[Configuration]:
        configs, tries = [], 0
        while len(configs) < self._n_configs and tries < 1000*self._n_configs:
            cfg  = self._configspace.sample_configuration()
            vals = [cfg[f"input_{i+1}"] for i in range(self.num_inputs)]
            if sum(vals) <= self.max_sum:
                configs.append(cfg)
            tries += 1
        if len(configs) < self._n_configs:
            self.logger.warning(
                f"Only generated {len(configs)} valid configs out of {self._n_configs}")
        return configs